esphome:
  name: "sofarsolar"
  on_boot:
    - priority: 250  # after sensors initialize
      then:
        - lambda: |-
            switch (id(passive_submode_id)) {
              case 0:
                id(passive_submode_string).publish_state("Passive Auto");
                break;
              case 1:
                id(passive_submode_string).publish_state("Scheduled Charge");
                break;
              default:
                id(passive_submode_string).publish_state("Unknown");
                break;
            }
    - priority: 600
      then:
        - script.execute: set_passive_timeout            
    - priority: 800
      then:
        - lambda: |-
            int mode = (int)id(current_mode).state;

            std::string label;
            if (mode == 0) label = "Self Use";
            else if (mode == 1) label = "Time Of Use";
            else if (mode == 3) label = "Passive";
            else if (mode == 4) label = "Peak Shaving";
            else label = "Unknown";

            ESP_LOGI("boot", "Syncing battery_inverter_mode_select to '%s' from mode %d", label.c_str(), mode);
            id(battery_inverter_mode_select).publish_state(label);          
esp32:
  board: esp-wrover-kit
  framework:
    type: arduino

substitutions:
  devicename: "sofarsolar"

# Enable logging
logger:
  baud_rate: 0
  logs:
    modbus_controller.sensor: ERROR
    sensor: ERROR

# Enable Home Assistant API
api:

ota:
  platform: esphome

web_server:
  port: 80

time:
  - platform: homeassistant
    id: esptime

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  output_power: 20.5db
  manual_ip:
    static_ip: 10.10.50.99
    gateway: 10.10.50.254
    subnet: 255.255.255.0  
 
uart:
  id: modbus_uart
  tx_pin: GPIO17
  rx_pin: GPIO16
  baud_rate: 9600
  stop_bits: 1
  parity: NONE
  debug:
    direction: BOTH
    dummy_receiver: false
    # after:
    #   delimiter: [0xF8,0xF7,0xF6,0xF5]
      
modbus:
  send_wait_time: 200ms
  id: modbus1
  flow_control_pin: GPIO4
  uart_id: modbus_uart

modbus_controller:
  - id: sofar_inverter
    address: 0x01
    modbus_id: modbus1
    command_throttle: 0ms
    setup_priority: -10
    update_interval: 15s
  - id: sofar_inverter_rapid
    address: 0x01
    modbus_id: modbus1
    command_throttle: 0ms
    setup_priority: -10
    update_interval: 5s

globals:
  - id: passive_mode_enabled
    type: bool
    restore_value: false
    initial_value: "false"

  - id: passive_submode_id
    type: uint8_t
    restore_value: true
    initial_value: '0'

  - id: scheduled_charge_active_written
    type: bool
    restore_value: false
    initial_value: "false"
  - id: last_blo
    type: int32_t
    restore_value: no
    initial_value: '0'
  - id: last_bup
    type: int32_t
    restore_value: no
    initial_value: '0'
  - id: last_gdes
    type: int32_t
    restore_value: no
    initial_value: '0'

number:
  - platform: template
    name: "Passive Charge Power"
    id: passive_charge_power
    min_value: 500
    max_value: 5000
    restore_value: True
    step: 100
    mode: box
    unit_of_measurement: "W"
    optimistic: true

  - platform: template
    name: "Scheduled Charge Target SoC"
    id: scheduled_charge_target_soc
    min_value: 10
    max_value: 100
    restore_value: True
    step: 1
    unit_of_measurement: "%"
    optimistic: true
    mode: box

  - platform: modbus_controller
    id: inverter_storage_mode_number
    name: "Inverter Storage Mode"
    address: 0x1110
    register_type: holding
    value_type: U_WORD
    min_value: 0
    max_value: 5
    step: 1
    use_write_multiple: true
    modbus_controller_id: sofar_inverter
    on_value:
      then:
        - logger.log:
            format: "Inverter Storage Mode updated: %.0f"
            args: ["x"]
        - lambda: |-
            id(current_mode).publish_state((int)x);

select:
  - platform: template
    name: "Battery/Inverter Mode"
    id: battery_inverter_mode_select
    optimistic: true
    restore_value: true
    options:
      - "Self Use"
      - "Time Of Use"
      - "Passive"
      - "Peak Shaving"
    set_action:
      then:
        - lambda: |-
            std::string mode = x.c_str();
            int inverter_mode = 3;
            if (mode == "Self Use") inverter_mode = 0;
            else if (mode == "Time Of Use") inverter_mode = 1;
            else if (mode == "Passive") inverter_mode = 3;
            else if (mode == "Peak Shaving") inverter_mode = 4;
            else return;

            if ((int)id(current_mode).state != inverter_mode) {
              id(inverter_storage_mode_number).make_call().set_value(inverter_mode).perform();
              id(current_mode).publish_state(inverter_mode);
            }

            id(inverter_storage_mode_number).make_call().set_value(inverter_mode).perform();
            id(battery_mode_string).publish_state(mode);

        - if:
            condition:
              lambda: 'return x == "Passive";'
            then:
              - select.set:
                  id: passive_mode_subselect
                  option: "Passive (Auto)"
              - script.execute:
                  id: apply_passive_submode
                  submode: "Passive (Auto)"

  - platform: template
    name: "Passive Mode Subtype"
    id: passive_mode_subselect
    optimistic: true
    restore_value: true
    options:
      - "Passive (Auto)"
      - "Passive Charge"
      - "Passive Discharge"
      - "Passive Export"
    initial_option: "Passive (Auto)"
    set_action:
      then:
        - lambda: |-
            ESP_LOGI("passive_subselect", "Selected passive submode: %s", x.c_str());
            id(passive_submode_string).publish_state(x);

            if (x == "Passive (Auto)") {
              id(passive_submode_id) = 0;
            } else if (x == "Passive Charge") {
              id(passive_submode_id) = 1;
            } else if (x == "Passive Discharge") {
              id(passive_submode_id) = 2;
            } else if (x == "Passive Export") {
              id(passive_submode_id) = 3;
            }

            if ((int)id(current_mode).state != 3) {
              ESP_LOGI("passive_subselect", "Switching main inverter mode to Passive (3)");
              id(inverter_storage_mode_number).make_call().set_value(3).perform();
              id(current_mode).publish_state(3);
              id(battery_mode_string).publish_state("Passive");
            }
        - delay: 500ms
        - script.execute:
            id: apply_passive_submode
            submode: !lambda 'return x;'

script:
  - id: set_passive_timeout
    mode: single
    then:
      - lambda: |-
          const uint16_t timeout_value = 300;  // in seconds
          const uint16_t timeout_action = 1;   // 1 = return to energy storage mode

          std::vector<uint8_t> cmd = {
            0x01, 0x10,         // Slave ID + Write Multiple Registers
            0x11, 0x84,         // Start at register 0x1184
            0x00, 0x02,         // Write 2 registers
            0x04,               // 4 bytes total
            (uint8_t)(timeout_value >> 8), (uint8_t)(timeout_value & 0xFF),
            (uint8_t)(timeout_action >> 8), (uint8_t)(timeout_action & 0xFF)
          };

          id(modbus1).send_raw(cmd);
          ESP_LOGI("timeout", "Passive timeout set: %ds with action %d", timeout_value, timeout_action);

  - id: apply_passive_submode
    mode: restart
    parameters:
      submode: string
    then:
      - lambda: |-
          id(passive_submode_string).publish_state(submode);

          const uint16_t BASE_REGISTER = 0x1187;

          int32_t gdes = 0;
          int32_t blo = 0;
          int32_t bup = 0;

          if (submode == "Passive Charge") {
            int32_t charge_power = (int32_t) id(passive_charge_power).state;
            gdes = 0;
            blo = charge_power;
            bup = charge_power;
          } else if (submode == "Passive Discharge") {
            gdes = 0;
            blo = -1000;
            bup = -5000;
          } else if (submode == "Passive Export") {
            gdes = -5000;
            blo = -5000;
            bup = -5000;
          } else {
            ESP_LOGI("passive_mode", "Passive Auto – skipping manual write.");
            return;
          }

          std::vector<uint8_t> payload = {
            (uint8_t)(gdes >> 24), (uint8_t)(gdes >> 16),
            (uint8_t)(gdes >> 8),  (uint8_t)(gdes & 0xFF),
            (uint8_t)(blo >> 24),  (uint8_t)(blo >> 16),
            (uint8_t)(blo >> 8),   (uint8_t)(blo & 0xFF),
            (uint8_t)(bup >> 24),  (uint8_t)(bup >> 16),
            (uint8_t)(bup >> 8),   (uint8_t)(bup & 0xFF)
          };

          std::vector<uint8_t> cmd = {
            0x01, 0x10,
            (uint8_t)(BASE_REGISTER >> 8), (uint8_t)(BASE_REGISTER & 0xFF),
            0x00, 0x06, 0x0C
          };
          cmd.insert(cmd.end(), payload.begin(), payload.end());
          id(modbus1).send_raw(cmd);

          ESP_LOGI("passive_subselect", "Sent 6-register block (Gdes: %d, Blo: %d, Bup: %d)", gdes, blo, bup);

interval:
  - interval: 10s
    id: passive_control_loop
    then:
      - lambda: |-
          auto now = id(esptime).now();
          int now_minutes = now.hour * 60 + now.minute;
          int start_minutes = (int)id(scheduled_charge_start_hour).state * 60 + (int)id(scheduled_charge_start_minute).state;
          int end_minutes   = (int)id(scheduled_charge_end_hour).state * 60 + (int)id(scheduled_charge_end_minute).state;

          float soc = id(inverter_soc_bat).state;
          float target_soc = id(scheduled_charge_target_soc).state;
          float pv = id(inverter_pv_power).state;

          bool within_schedule = (start_minutes <= end_minutes)
              ? (now_minutes >= start_minutes && now_minutes < end_minutes)
              : (now_minutes >= start_minutes || now_minutes < end_minutes);

          bool below_target = soc < target_soc;

          int32_t gdes = 0;
          int32_t blo = 0;
          int32_t bup = 0;

          if (within_schedule) {
            if (below_target) {
              int32_t charge_power = (int32_t)id(passive_charge_power).state;
              blo = charge_power;
              bup = charge_power;

              if (id(scheduled_charge_status).state != "Active") {
                id(scheduled_charge_status).publish_state("Active");
                id(passive_submode_id) = 1;
                id(passive_submode_string).publish_state("Passive Charge");
                id(battery_mode_string).publish_state("Passive Charge");
                ESP_LOGI("scheduled_charge", "Passive Charge active → %dW", charge_power);
              }
            } else {
              blo = 0;
              bup = 0;

              if (id(scheduled_charge_status).state != "Active") {
                id(scheduled_charge_status).publish_state("Active");
                id(passive_submode_id) = 1;
                id(passive_submode_string).publish_state("Passive Charge");
                id(battery_mode_string).publish_state("Passive Charge");
                ESP_LOGI("scheduled_charge", "SOC %.1f%% ≥ %.1f%% → Battery floating (no discharge)", soc, target_soc);
              }
            }

            if ((int)id(current_mode).state != 3) {
              id(inverter_storage_mode_number).make_call().set_value(3).perform();
              id(current_mode).publish_state(3);
            }

          } else {
            if (id(scheduled_charge_status).state != "Inactive") {
              id(scheduled_charge_status).publish_state("Inactive");
              id(passive_submode_id) = 0;
              id(passive_submode_string).publish_state("Passive Auto");
              id(battery_mode_string).publish_state("Passive");
              ESP_LOGI("scheduled_charge", "Schedule ended → Switching to Passive Auto");
            }

            if ((int)id(current_mode).state != 3) {
              id(inverter_storage_mode_number).make_call().set_value(3).perform();
              id(current_mode).publish_state(3);
            }

            if (pv > 5200.0 && soc < 100.0) {
              int32_t charge_power = 0;
              if (pv > 7500.0) charge_power = 3000;
              else if (pv > 7000.0) charge_power = 2500;
              else if (pv > 6500.0) charge_power = 2000;
              else if (pv > 6000.0) charge_power = 1500;
              else charge_power = 1000;

              blo = charge_power;
              bup = charge_power;

              ESP_LOGI("passive_mode", "PV %.1fW → Passive Auto charge at %dW", pv, charge_power);
            } else {
              int32_t charge_power = (int32_t)id(passive_charge_power).state;
              blo = -5000;
              bup = charge_power;

              ESP_LOGI("passive_mode", "PV %.1fW < 5200 or SOC %.1f%% = 100%% → Floating battery in Passive", pv, soc);
            }
          }

          if (blo != id(last_blo) || bup != id(last_bup) || gdes != id(last_gdes)) {
            std::vector<uint8_t> payload = {
              (uint8_t)(gdes >> 24), (uint8_t)(gdes >> 16),
              (uint8_t)(gdes >> 8),  (uint8_t)(gdes & 0xFF),
              (uint8_t)(blo >> 24),  (uint8_t)(blo >> 16),
              (uint8_t)(blo >> 8),   (uint8_t)(blo & 0xFF),
              (uint8_t)(bup >> 24),  (uint8_t)(bup >> 16),
              (uint8_t)(bup >> 8),   (uint8_t)(bup & 0xFF)
            };

            std::vector<uint8_t> cmd = {
              0x01, 0x10, 0x11, 0x87, 0x00, 0x06, 0x0C
            };
            cmd.insert(cmd.end(), payload.begin(), payload.end());

            id(modbus1).send_raw(cmd);

            ESP_LOGI("passive_mode", "Grid=%dW Charge=%dW SOC=%.1f%% PV=%.1fW", gdes, blo, soc, pv);

            id(last_blo) = blo;
            id(last_bup) = bup;
            id(last_gdes) = gdes;
          }


switch:
  - platform: template
    name: "Enable Passive Mode"
    id: enable_passive_mode
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true

sensor:
  - platform: homeassistant
    id: scheduled_charge_start_hour
    entity_id: input_datetime.sofar_charge_start_time
    attribute: hour

  - platform: homeassistant
    id: scheduled_charge_start_minute
    entity_id: input_datetime.sofar_charge_start_time
    attribute: minute

  - platform: homeassistant
    id: scheduled_charge_end_hour
    entity_id: input_datetime.sofar_charge_end_time
    attribute: hour

  - platform: homeassistant
    id: scheduled_charge_end_minute
    entity_id: input_datetime.sofar_charge_end_time
    attribute: minute

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    id: current_mode
    name: "Current Inverter Storage Mode"
    address: 0x1110  # example register for mode
    register_type: holding
    value_type: U_WORD
    on_value:
      then:
        - lambda: |-
            int val = (int)id(current_mode).state;
            std::string mode_str;
            switch(val) {
              case 0: mode_str = "Self Use"; break;
              case 1: mode_str = "Time-of-Use"; break;
              case 3: mode_str = "Passive"; break;
              case 4: mode_str = "Peak Shaving"; break;
              default: mode_str = "Unknown"; break;
            }
            id(battery_mode_string).publish_state(mode_str);
    filters:
      - lambda: |-
          if (x > 4) {
            ESP_LOGW("modbus", "Ignoring out-of-range inverter storage mode value: %f", x);
            return NAN;
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    internal: True
    id: inverter_status
    address: 0x0404
    register_type: holding
    value_type: U_WORD
    filters: 
      - debounce: 
          seconds: 5
    on_value:
      then:
        - lambda: |-
            uint16_t value = static_cast<uint16_t>(id(inverter_status).state);
            std::string status_text;
            switch (value) {
              case 0: status_text = "Wait"; break;
              case 1: status_text = "Check"; break;
              case 2: status_text = "On Grid"; break;
              case 3: status_text = "Emergency Mode (EPS)"; break;
              case 4: status_text = "Error"; break;
              case 5: status_text = "Permanent Error"; break;
              case 6: status_text = "Firmware Updating"; break;
              case 7: status_text = "Self Charging"; break;
              default:
                ESP_LOGW("modbus", "Unexpected inverter status value: %u", value);
                return;
            }
            id(inverter_status_text).publish_state(status_text);


  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Maximum Charge/Discharge Limit"
    id: charge_power_limit_sensor
    address: 0x118B
    register_type: holding
    value_type: S_DWORD
    unit_of_measurement: "W"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          if (x < -10000 || x > 10000) {
            ESP_LOGW("modbus", "Ignoring out-of-range charge limit value: %f", x);
            return NAN;
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Minimum Charge/Discharge Limit"
    id: discharge_power_limit_sensor
    address: 0x1189
    register_type: holding
    value_type: S_DWORD
    unit_of_measurement: "W"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          if (x < -10000 || x > 10000) {
            ESP_LOGW("modbus", "Ignoring out-of-range discharge limit value: %f", x);
            return NAN;
          }
          return x;

######grid export/import
#  - platform: modbus_controller
#    modbus_controller_id: sofar_inverter
#    name: "Grid Export Limit"
#    id: grid_export_limit_sensor
#    register_type: holding
#    address: 0x118D
#    value_type: S_DWORD
#    unit_of_measurement: "W"
#    accuracy_decimals: 0

#  - platform: modbus_controller
#    modbus_controller_id: sofar_inverter
#    name: "Grid Import Limit"
#    id: grid_import_limit_sensor
#    register_type: holding
#    address: 0x118F
#    value_type: S_DWORD
#    unit_of_measurement: "W"
#    accuracy_decimals: 0

  - platform: wifi_signal
    id: inverter_wifi_signal
    name: WiFi Signal
    update_interval: 60s

  - platform: uptime
    id: inverter_uptime
    name: Uptime
    filters:
      - lambda: return x / 60.0;
    unit_of_measurement: minutes

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Voltage DC1
    id: inverter_dc_v1
    register_type: holding
    address: 0x0584
    unit_of_measurement: "V"
    icon: "mdi:alpha-v-circle-outline"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
      - lambda: |-
          if (x < 0 || x > 400) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;    

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Current DC1
    id: inverter_dc_c1
    register_type: holding
    address: 0x0585
    unit_of_measurement: "A"
    icon: "mdi:alpha-a-circle-outline"
    value_type: U_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
      - lambda: |-
          if (x < 0 || x > 120) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;     

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Voltage DC2
    id: inverter_dc_v2
    register_type: holding
    address: 0x0587
    unit_of_measurement: "V"
    icon: "mdi:alpha-v-circle-outline"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
      - lambda: |-
          if (x < 0 || x > 400) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Current DC2
    id: inverter_dc_c2
    register_type: holding
    address: 0x0588
    unit_of_measurement: "A"
    icon: "mdi:alpha-a-circle-outline"
    value_type: U_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
      - lambda: |-
          if (x < 0 || x > 120) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Power DC1
    id: inverter_dc_power1
    register_type: holding
    address: 0x0586
    unit_of_measurement: "W"
    device_class: "power"
    value_type: U_WORD
    filters:
      - multiply: 10
      - lambda: |-
          if (x < 0 || x > 5000) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Power DC2
    id: inverter_dc_power2
    register_type: holding
    address: 0x0589
    unit_of_measurement: "W"
    device_class: "power"
    value_type: U_WORD
    filters:
      - multiply: 10
      - lambda: |-
          if (x < 0 || x > 5000) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: template
    name: PV Power
    id: inverter_pv_power
    unit_of_measurement: "W"
    update_interval: 5s
    lambda: return id(inverter_dc_power1).state + id(inverter_dc_power2).state;
    filters:
      - lambda: |-
          if (x < 0 || x > 9000) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;


  - platform: total_daily_energy
    name: "DC 1 Daily Energy"
    id: dc1_daily_energy
    restore: true
    power_id: inverter_dc_power1
    unit_of_measurement: kWh
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "DC 2 Daily Energy"
    id: dc2_daily_energy    
    restore: true
    power_id: inverter_dc_power2
    unit_of_measurement: kWh
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: AC Power
    id: inverter_ac_power
    register_type: holding
    address: 0x0485
    unit_of_measurement: "W"
    device_class: "power"
    value_type: S_WORD
    filters:
      - multiply: 10
      - lambda: |-
          if (x < -120000 || x > 12000) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: AC Grid Power
    id: inverter_ac_grid_power
    register_type: holding
    address: 0x0488
    unit_of_measurement: "W"
    device_class: "power"
    value_type: S_WORD
    filters:
      - multiply: 10
      - lambda: |-
          if (x < -12000 || x > 12000) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: AC Power Load
    id: inverter_ac_power_load
    register_type: holding
    address: 0x04AF
    unit_of_measurement: "W"
    device_class: "power"
    value_type: U_WORD
    filters:
      - multiply: 10
      - lambda: |-
          if (x < -12000 || x > 12000) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: AC Power Load (EPS)
    id: inverter_ac_active_power_load
    register_type: holding
    address: 0x0504
    unit_of_measurement: "W"
    device_class: "power"
    value_type: U_WORD
    filters:
      - multiply: 10      
      - lambda: |-
          if (x < -500 || x > 500) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: AC Frequency
    id: inverter_ac_freq
    register_type: holding
    address: 0x0484
    unit_of_measurement: "Hz"
    icon: "mdi:current-ac"
    value_type: U_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
      - lambda: |-
          if (x < 0 || x > 55) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: AC Voltage
    id: inverter_ac_v1
    register_type: holding
    address: 0x048D
    unit_of_measurement: "V"
    icon: "mdi:alpha-v-circle-outline"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
      - lambda: |-
          if (x < 0 || x > 275) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;
  
  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: AC Current
    id: inverter_ac_c1
    register_type: holding
    address: 0x0492
    unit_of_measurement: "A"
    icon: "mdi:alpha-a-circle-outline"
    value_type: U_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Production Total
    id: inverter_production_total
    register_type: holding
    state_class: total_increasing
    address: 0x0686
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
 
  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Production Daily
    id: inverter_production_daily
    register_type: holding
    state_class: total_increasing
    address: 0x0684
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
      - lambda: |-
          if (x < 0 || x > 60) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Consumption Total
    id: inverter_consumption_total
    register_type: holding
    state_class: total_increasing
    address: 0x068A
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
 
  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Consumption Daily
    id: inverter_consumption_daily
    register_type: holding
    state_class: total_increasing
    address: 0x0688
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
      - lambda: |-
          if (x < 0 || x > 60) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Import Total
    id: inverter_import_total
    register_type: holding
    state_class: total_increasing
    address: 0x068E
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
 
  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Import Daily
    id: inverter_import_daily
    state_class: total_increasing
    register_type: holding
    address: 0x068C
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
      - lambda: |-
          if (x < 0 || x > 60) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Export Total
    id: inverter_Export_total
    state_class: total_increasing
    register_type: holding
    address: 0x0692
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
 
  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Export Daily
    id: inverter_export_daily
    state_class: total_increasing
    register_type: holding
    address: 0x0690
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
      - lambda: |-
          if (x < 0 || x > 60) {
            return NAN;  // Ignore invalid or extreme readings
          }
          return x;


  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Inverter Temp 
    id: inverter_temp_inverter
    register_type: holding
    address: 0x041A
    unit_of_measurement: " C"
    device_class: "temperature"
    value_type: U_WORD
  
  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Reflux power
    id: inverter_reflux_power
    register_type: holding
    address: 0x1024
    unit_of_measurement: "W"
    value_type: U_WORD
    filters:
      - multiply: 100

#### Battery #####

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Battery Voltage
    id: inverter_voltage_bat
    icon: "mdi:car-battery"
    register_type: holding
    address: 0x0604
    unit_of_measurement: "V"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Battery Current
    id: inverter_current_bat
    icon: "mdi:car-battery"
    register_type: holding
    address: 0x0605
    unit_of_measurement: "A"
    value_type: S_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Battery Power
    id: inverter_power_bat
    icon: "mdi:car-battery"
    register_type: holding
    address: 0x0606
    unit_of_measurement: "W"
    device_class: "power"
    value_type: S_WORD
    filters:
      - multiply: 10


  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Battery Temp
    id: inverter_temperature_bat
    icon: "mdi:car-battery"
    register_type: holding
    address: 0x0607
    unit_of_measurement: " C"
    device_class: "temperature"
    value_type: U_WORD
 
  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Battery SOC
    id: inverter_soc_bat
    icon: "mdi:car-battery"
    register_type: holding
    address: 0x0608
    unit_of_measurement: "%"
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Battery SOH
    id: inverter_soh_bat
    icon: "mdi:car-battery"
    register_type: holding
    address: 0x0609
    unit_of_measurement: "%"
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Battery Cycles
    id: inverter_cycle_bat
    icon: "mdi:car-battery"
    register_type: holding
    address: 0x9073
    unit_of_measurement: "Cycles"
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Battery Charge Daily
    id: inverter_battery_charge_daily
    state_class: total_increasing
    register_type: holding
    address: 0x0695
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: S_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: Battery Discharge Daily
    id: inverter_battery_discharge_daily
    state_class: total_increasing
    register_type: holding
    address: 0x0699
    unit_of_measurement: "kWh"
    device_class: "energy"
    value_type: S_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

### Fault Sensors ###

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x0405"
    id: fault_reg_0
    register_type: holding
    address: 0x0405
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x0406"
    id: fault_reg_1
    register_type: holding
    address: 0x0406
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x0407"
    id: fault_reg_2
    register_type: holding
    address: 0x0407
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x0408"
    id: fault_reg_3
    register_type: holding
    address: 0x0408
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x0409"
    id: fault_reg_4
    register_type: holding
    address: 0x0409
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x040A"
    id: fault_reg_5
    register_type: holding
    address: 0x040A
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x040B"
    id: fault_reg_6
    register_type: holding
    address: 0x040B
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x040C"
    id: fault_reg_7
    register_type: holding
    address: 0x040C
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x040D"
    id: fault_reg_8
    register_type: holding
    address: 0x040D
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x040E"
    id: fault_reg_9
    register_type: holding
    address: 0x040E
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x040F"
    id: fault_reg_10
    register_type: holding
    address: 0x040F
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: sofar_inverter
    name: "Fault Register 0x0410"
    id: fault_reg_11
    register_type: holding
    address: 0x0410
    value_type: U_WORD
    internal: true


text_sensor:
  - platform: homeassistant
    id: scheduled_charge_start_time
    entity_id: input_datetime.scheduled_charge_start_time
    internal: true

  - platform: template
    name: "Scheduled Charge Status"
    id: scheduled_charge_status
    icon: "mdi:calendar-clock"
    update_interval: never
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("scheduled_charge_status", "State changed to: %s", x.c_str());
            
  - platform: homeassistant
    id: scheduled_charge_end_time
    entity_id: input_datetime.scheduled_charge_end_time
    internal: true

  - platform: template
    name: "Passive Submode ID"
    lambda: 'return to_string(id(passive_submode_id));'
    update_interval: 10s

  - platform: template
    name: "Passive Submode"
    id: passive_submode_string
    icon: "mdi:format-list-bulleted"

  - platform: template
    name: "Battery Mode String"
    id: battery_mode_string

  - platform: template
    name: "Inverter Status"
    id: inverter_status_text

  - platform: template
    name: "Inverter Fault Status"
    lambda: |-
      static const char* fault_descriptions[] = {
        "OK",
        "ID01 Grid Overvoltage Protection",
        "ID02 Grid Undervoltage Protection",
        "ID03 Grid Overfrequency Protection",
        "ID04 Grid Underfrequency Protection",
        "ID05 Leakage current fault",
        "ID06 High penetration error",
        "ID07 Low penetration error",
        "ID08 Islanding error",
        "ID09 Grid voltage transient value overvoltage 1",
        "ID10 Grid voltage transient value overvoltage 2",
        "ID11 Grid line voltage error",
        "ID12 Inverter voltage error",
        "ID13 Anti-backflow overload",
        "ID14 Grid line voltage unbalance",
        "ID15 Inverter transient overvoltage",
        "ID16 Sudden grid phase change",
        "ID17 Grid current sampling error",
        "ID18 Grid current DC component sampling error (AC side)",
        "ID19 Grid voltage sampling error (DC side)",
        "ID20 Grid voltage sampling error (AC side)",
        "ID21 Leakage current sampling error (DC side)",
        "ID22 Leakage current sampling error (AC side)",
        "ID23 Load voltage DC component sampling error",
        "ID24 DC input current sampling error",
        "ID25 DC component sampling error of grid current (DC side)",
        "ID26 DC input branch current sampling error",
        "ID27 PV low impedance to ground",
        "ID28 PID abnormal output",
        "ID29 Leakage current consistency error",
        "ID30 Grid voltage consistency error",
        "ID31 DCI consistency error",
        "ID32 Neutral ground fault",
        "ID033 SPI communication error (DC side)",
        "ID034 SPI communication error (AC side)",
        "ID035 Chip error (DC side)",
        "ID036 Chip error (AC side)",
        "ID037 Auxiliary power error",
        "ID038 Inverter soft start failure",
        "ID039 Arc shutdown protection",
        "ID040 Weak light detection failure",
        "ID041 Relay detection failure",
        "ID042 Low insulation impedance",
        "ID043 Grounding error",
        "ID044 Input mode setting error",
        "ID045 CT error",
        "ID046 Input reversal error",
        "ID047 Parallel error",
        "ID048 Serial number error",
        "ID049 Battery temperature protection",
        "ID050 Heatsink 1 temperature protection",
        "ID051 Heater 2 temperature protection",
        "ID052 Heater 3 temperature protection",
        "ID053 Heatsink 4 temperature protection",
        "ID054 Radiator 5 temperature protection",
        "ID055 Radiator 6 temperature protection",
        "ID056 Reserved",
        "ID057 Ambient temperature 1 protection",
        "ID058 Ambient temperature 2 protection",
        "ID059 Module 1 temperature protection",
        "ID060 Module 2 temperature protection",
        "ID061 Module 3 temperature protection",
        "ID062 Module temperature difference is too large",
        "ID063 Reserved",
        "ID064 Reserved",
        "ID065 Bus voltage RMS unbalance",
        "ID066 Bus voltage transient value unbalance",
        "ID067 Bus undervoltage during grid connection",
        "ID068 Bus bar low voltage",
        "ID069 PV overvoltage",
        "ID070 Battery overvoltage",
        "ID071 LLC bus overvoltage protection",
        "ID072 Inverter bus voltage RMS software overvoltage",
        "ID073 Inverter bus voltage transient value software overvoltage",
        "ID074 Flying Cross Capacitor Overvoltage Protection",
        "ID075 Flying Cross capacitor undervoltage protection",
        "ID076 Reserved",
        "ID077 Reserved",
        "ID078 Reserved",
        "ID079 Reserved",
        "ID080 Reserved",
        "ID081 Battery overcurrent software protection",
        "ID082 DCI overcurrent protection",
        "ID083 Output transient current protection",
        "ID084 Buck-Boost software overcurrent",
        "ID085 Output RMS current protection",
        "ID086 PV instantaneous current overcurrent software protection",
        "ID087 PV parallel uneven current",
        "ID088 Output current unbalance",
        "ID089 PV software overcurrent protection",
        "ID090 Balanced circuit overcurrent protection",
        "ID091 Resonance protection",
        "ID092 Reserved",
        "ID093 Reserved",
        "ID094 Reserved",
        "ID095 Reserved",
        "ID096 Reserved",
        "ID097 LLC bus hardware overvoltage",
        "ID098 Inverter bus hardware overvoltage",
        "ID099 Buck-Boost hardware overcurrent",
        "ID100 Battery hardware overcurrent",
        "ID101 Reserved",
        "ID102 PV hardware overcurrent",
        "ID103 AC output hardware overcurrent",
        "ID104 Hardware differential overcurrent",
        "ID105 Meter communication error",
        "ID106 Serial number model error",
        "ID107 Hardware version mismatch",
        "ID108 Reserved",
        "ID109 Reserved",
        "ID110 Overload protection 1",
        "ID111 Overload protection 2",
        "ID112 Overload protection 3",
        "ID113 Overtemperature load shedding",
        "ID114 Frequency down load",
        "ID115 Frequency loading",
        "ID116 Voltage down load",
        "ID117 Voltage loading",
        "ID118 Low temperature load shedding",
        "ID119 Reserved",
        "ID120 Reserved",
        "ID121 Lightning protection failure (DC)",
        "ID122 Lightning protection failure (AC)",
        "ID123 Reserved",
        "ID124 Battery low voltage protection",
        "ID125 Battery low voltage shutdown",
        "ID126 Battery low voltage pre-alarm",
        "ID127 Reserved",
        "ID128 Reserved",
        "ID129 AC output hardware overcurrent permanent fault",
        "ID130 Bus overvoltage permanent fault",
        "ID131 Bus hardware overvoltage permanent fault",
        "ID132 PV uneven flow permanent fault",
        "ID133 Battery overcurrent permanent fault in EPS mode",
        "ID134 Output transient overcurrent permanent fault",
        "ID135 AC current unbalance permanent fault",
        "ID136 Inverter soft start failure fault",
        "ID137 Input mode setting error permanent fault",
        "ID138 Input overcurrent permanent fault",
        "ID139 Input hardware overcurrent permanent fault",
        "ID140 Relay permanent fault",
        "ID141 Bus unbalance permanent fault",
        "ID142 Lightning protection permanent fault (DC side)",
        "ID143 Lightning protection permanent fault (AC side)",
        "ID144 Grid relay fault",
        "ID145 USB fault",
        "ID146 WIFI fault",
        "ID147 Bluetooth fault",
        "ID148 RTC clock fault",
        "ID149 Communication board EEPROM error",
        "ID150 Communication board FLASH error",
        "ID151 The battery is partially disconnected",
        "ID152 Safety regulation version error",
        "ID153 SCI communication error (DC side)",
        "ID154 SCI communication error (AC side)",
        "ID155 SCI communication error (convergence board side)",
        "ID156 Software version inconsistency",
        "ID157 Lithium battery 1 communication error",
        "ID158 Lithium battery 2 communication error",
        "ID159 Lithium battery 3 communication error",
        "ID160 Lithium battery 4 communication error",
        "ID161 Forced shutdown",
        "ID162 Remote shutdown",
        "ID163 Drms0 shutdown",
        "ID164 Power station communication failure shutdown",
        "ID165 Remote down load",
        "ID166 Logic interface down load",
        "ID167 Anti-Reverse Flow Downgrade",
        "ID168 Reserved",
        "ID169 Fan 1 failure",
        "ID170 Fan 2 failure",
        "ID171 Fan 3 failure",
        "ID172 Fan 4 failure",
        "ID173 Fan 5 failure",
        "ID174 Fan 6 failure",
        "ID175 Fan 7 failure",
        "ID176 Meter communication failure",
        "ID177 BMS overvoltage protection",
        "ID178 BMS undervoltage protection",
        "ID179 BMS high temperature protection",
        "ID180 BMS low temperature protection",
        "ID181 BMS overcurrent protection",
        "ID182 BMS short circuit protection",
        "ID183 BMS version inconsistency",
        "ID184 BMS CAN version inconsistency",
        "ID185 BMS CAN version is too low",
        "ID186 Battery discharge overtemperature protection",
        "ID187 Battery discharge low temperature protection",
        "ID188 Battery charging overtemperature protection",
        "ID189 Arc device communication failure",
        "ID190 Battery charging low temperature protection",
        "ID191 PID repair failed",
        "ID192 PLC module heartbeat loss"
      };

      float regs[] = {
        id(fault_reg_0).state,
        id(fault_reg_1).state,
        id(fault_reg_2).state,
        id(fault_reg_3).state,
        id(fault_reg_4).state,
        id(fault_reg_5).state,
        id(fault_reg_6).state,
        id(fault_reg_7).state,
        id(fault_reg_8).state,
        id(fault_reg_9).state,
        id(fault_reg_10).state,
        id(fault_reg_11).state
      };

      std::string faults;
      for (int i = 0; i < 12; i++) {
        auto reg = (uint16_t)regs[i];
        for (int bit = 0; bit < 16; bit++) {
          int idx = i * 16 + bit;
          if (((reg >> bit) & 1) && idx < (sizeof(fault_descriptions) / sizeof(fault_descriptions[0]))) {
            faults += fault_descriptions[idx];
            faults += ", ";
          }
        }
      }

      if (faults.empty()) return std::string("OK");
      return faults.substr(0, faults.size() - 2); // remove trailing comma

    #update_interval: 60s
    icon: mdi:alert-circle
